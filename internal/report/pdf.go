package report

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/jamesruggles/reconsuite/internal/database"
	"github.com/signintech/gopdf"
)

func (g *Generator) SavePDF(projectID int64) (string, *database.Report, error) {
	project, err := g.db.GetProject(projectID)
	if err != nil || project == nil {
		return "", nil, fmt.Errorf("project not found")
	}

	scans, err := g.db.ListScansByProject(projectID)
	if err != nil {
		return "", nil, fmt.Errorf("listing scans: %w", err)
	}

	results, err := g.db.GetResultsByProject(projectID)
	if err != nil {
		return "", nil, fmt.Errorf("listing results: %w", err)
	}

	pdf := gopdf.GoPdf{}
	pdf.Start(gopdf.Config{PageSize: *gopdf.PageSizeA4})

	// Use built-in Helvetica (no external font file needed)
	if err := pdf.AddTTFFont("helvetica", "/System/Library/Fonts/Helvetica.ttc"); err != nil {
		// Fallback: try a common path on Linux
		if err2 := pdf.AddTTFFont("helvetica", "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf"); err2 != nil {
			return "", nil, fmt.Errorf("loading font: %w (also tried: %v)", err, err2)
		}
	}

	p := &pdfWriter{pdf: &pdf, y: 40, pageH: 842, pageW: 595, marginL: 40, marginR: 40}

	// Title page
	pdf.AddPage()
	p.y = 200
	p.setFont(24)
	p.writeCenter("Reconnaissance Report")
	p.y += 40
	p.setFont(18)
	p.writeCenter(project.Name)
	p.y += 30
	p.setFont(12)
	p.writeCenter(time.Now().Format("January 2, 2006"))
	p.y += 15
	p.writeCenter("Generated by ReconSuite")

	// Scope page
	pdf.AddPage()
	p.y = 40
	p.heading("Scope")
	if project.Scope != "" {
		for _, target := range strings.Split(project.Scope, "\n") {
			target = strings.TrimSpace(target)
			if target != "" {
				p.bullet(target)
			}
		}
	} else {
		p.text("No scope defined.")
	}

	// Executive Summary
	p.heading("Executive Summary")
	p.text(fmt.Sprintf("This report covers %d scan(s) performed against the defined scope.", len(scans)))
	p.text(fmt.Sprintf("A total of %d finding(s) were recorded.", len(results)))
	p.y += 10

	typeCounts := make(map[string]int)
	for _, r := range results {
		typeCounts[r.ResultType]++
	}
	if len(typeCounts) > 0 {
		p.tableRow("Finding Type", "Count", true)
		for t, c := range typeCounts {
			p.tableRow(t, fmt.Sprintf("%d", c), false)
		}
		p.y += 10
	}

	// Methodology
	p.heading("Methodology")
	p.text("The following tools were used during reconnaissance:")
	toolSet := make(map[string]bool)
	for _, s := range scans {
		toolSet[s.Tool] = true
	}
	for tool := range toolSet {
		p.bullet(tool)
	}

	// Findings
	scansByType := map[string][]database.Scan{
		"passive": {}, "active": {}, "web": {},
	}
	for _, s := range scans {
		scansByType[s.ScanType] = append(scansByType[s.ScanType], s)
	}

	sections := []struct {
		title    string
		scanType string
	}{
		{"Passive Reconnaissance", "passive"},
		{"Active Reconnaissance", "active"},
		{"Web Reconnaissance", "web"},
	}

	for _, sec := range sections {
		sectionScans := scansByType[sec.scanType]
		if len(sectionScans) == 0 {
			continue
		}

		p.heading(sec.title)

		for _, scan := range sectionScans {
			scanResults, _ := g.db.GetResultsByScan(scan.ID)

			p.subheading(fmt.Sprintf("%s — %s", scan.Tool, scan.Target))
			p.text(fmt.Sprintf("Status: %s", scan.Status))

			if len(scanResults) > 0 {
				p.tableRow3("Type", "Key", "Value", true)
				for _, r := range scanResults {
					val := r.Value
					if len(val) > 60 {
						val = val[:60] + "..."
					}
					p.tableRow3(r.ResultType, r.Key, val, false)
				}
				p.y += 5
			}
		}
	}

	// Save
	os.MkdirAll(g.reportsDir, 0755)
	name := strings.ReplaceAll(strings.ToLower(project.Name), " ", "-")
	filename := fmt.Sprintf("%s-%s.pdf", name, time.Now().Format("20060102-150405"))
	path := filepath.Join(g.reportsDir, filename)

	if err := pdf.WritePdf(path); err != nil {
		return "", nil, fmt.Errorf("writing PDF: %w", err)
	}

	rpt := &database.Report{
		ProjectID: projectID,
		Title:     fmt.Sprintf("Recon Report — %s", name),
		Format:    "pdf",
		FilePath:  path,
	}
	if err := g.db.CreateReport(rpt); err != nil {
		return "", nil, fmt.Errorf("saving report record: %w", err)
	}

	return path, rpt, nil
}

// pdfWriter is a helper for writing structured content to a GoPdf.
type pdfWriter struct {
	pdf    *gopdf.GoPdf
	y      float64
	pageH  float64
	pageW  float64
	marginL float64
	marginR float64
}

func (p *pdfWriter) checkPage(needed float64) {
	if p.y+needed > p.pageH-40 {
		p.pdf.AddPage()
		p.y = 40
	}
}

func (p *pdfWriter) setFont(size int) {
	p.pdf.SetFont("helvetica", "", size)
}

func (p *pdfWriter) writeCenter(text string) {
	p.setFont(12) // measure width
	w, _ := p.pdf.MeasureTextWidth(text)
	x := (p.pageW - w) / 2
	if x < p.marginL {
		x = p.marginL
	}
	p.pdf.SetX(x)
	p.pdf.SetY(p.y)
	p.pdf.Cell(nil, text)
	p.y += 20
}

func (p *pdfWriter) heading(text string) {
	p.checkPage(30)
	p.y += 15
	p.setFont(16)
	p.pdf.SetX(p.marginL)
	p.pdf.SetY(p.y)
	p.pdf.Cell(nil, text)
	p.y += 25

	// Underline
	p.pdf.SetLineWidth(0.5)
	p.pdf.Line(p.marginL, p.y-5, p.pageW-p.marginR, p.y-5)
	p.y += 5
}

func (p *pdfWriter) subheading(text string) {
	p.checkPage(25)
	p.y += 8
	p.setFont(13)
	p.pdf.SetX(p.marginL)
	p.pdf.SetY(p.y)
	p.pdf.Cell(nil, text)
	p.y += 20
}

func (p *pdfWriter) text(text string) {
	p.checkPage(18)
	p.setFont(10)
	p.pdf.SetX(p.marginL)
	p.pdf.SetY(p.y)

	// Simple word wrap
	maxW := p.pageW - p.marginL - p.marginR
	words := strings.Fields(text)
	line := ""
	for _, word := range words {
		test := line
		if test != "" {
			test += " "
		}
		test += word
		w, _ := p.pdf.MeasureTextWidth(test)
		if w > maxW && line != "" {
			p.pdf.SetX(p.marginL)
			p.pdf.SetY(p.y)
			p.pdf.Cell(nil, line)
			p.y += 15
			p.checkPage(15)
			line = word
		} else {
			line = test
		}
	}
	if line != "" {
		p.pdf.SetX(p.marginL)
		p.pdf.SetY(p.y)
		p.pdf.Cell(nil, line)
		p.y += 15
	}
}

func (p *pdfWriter) bullet(text string) {
	p.checkPage(18)
	p.setFont(10)
	p.pdf.SetX(p.marginL + 10)
	p.pdf.SetY(p.y)
	p.pdf.Cell(nil, "• "+text)
	p.y += 15
}

func (p *pdfWriter) tableRow(col1, col2 string, header bool) {
	p.checkPage(18)
	if header {
		p.setFont(10)
	} else {
		p.setFont(9)
	}

	colW := (p.pageW - p.marginL - p.marginR) / 2
	p.pdf.SetX(p.marginL)
	p.pdf.SetY(p.y)
	p.pdf.Cell(nil, col1)
	p.pdf.SetX(p.marginL + colW)
	p.pdf.SetY(p.y)
	p.pdf.Cell(nil, col2)
	p.y += 15

	if header {
		p.pdf.SetLineWidth(0.3)
		p.pdf.Line(p.marginL, p.y-3, p.pageW-p.marginR, p.y-3)
	}
}

func (p *pdfWriter) tableRow3(col1, col2, col3 string, header bool) {
	p.checkPage(18)
	if header {
		p.setFont(10)
	} else {
		p.setFont(9)
	}

	totalW := p.pageW - p.marginL - p.marginR
	w1 := totalW * 0.2
	w2 := totalW * 0.3
	// w3 uses rest

	p.pdf.SetX(p.marginL)
	p.pdf.SetY(p.y)
	p.pdf.Cell(nil, truncate(col1, 20))
	p.pdf.SetX(p.marginL + w1)
	p.pdf.SetY(p.y)
	p.pdf.Cell(nil, truncate(col2, 30))
	p.pdf.SetX(p.marginL + w1 + w2)
	p.pdf.SetY(p.y)
	p.pdf.Cell(nil, truncate(col3, 50))
	p.y += 15

	if header {
		p.pdf.SetLineWidth(0.3)
		p.pdf.Line(p.marginL, p.y-3, p.pageW-p.marginR, p.y-3)
	}
}

func truncate(s string, maxLen int) string {
	if len(s) > maxLen {
		return s[:maxLen] + "..."
	}
	return s
}
